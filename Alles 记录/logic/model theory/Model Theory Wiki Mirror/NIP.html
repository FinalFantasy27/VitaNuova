<p><strong>NIP theories</strong> (also known as <strong>dependent theories</strong> or <strong>shatterproof theories</strong>) are a class of theories generalizing stable theories, but allowing for an ordering. Aside from stable theories, important examples are real closed fields, ACVF, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>p</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/81eac1e205430d1f40810df36a0edffdc367af36" class="mwe-math-fallback-image-inline" alt="{\displaystyle p}" /></span>-adically closed fields, and o-minimal theories.</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading">
<section id="mw-toc-heading" class="toctitle" lang="en" dir="ltr">
<h2>Contents</h2>
<p><span class="toctogglespan"></span></p>
</section>
<ul>
<li><a href="#Definitions"><span class="tocnumber">1</span> <span class="toctext">Definitions</span></a></li>
<li><a href="#Properties"><span class="tocnumber">2</span> <span class="toctext">Properties</span></a></li>
<li><a href="#Generically_stable_types"><span class="tocnumber">3</span> <span class="toctext">Generically stable types</span></a></li>
<li><a href="#Keisler_measures"><span class="tocnumber">4</span> <span class="toctext">Keisler measures</span></a></li>
<li><a href="#Counting_types;_dependent_dreams"><span class="tocnumber">5</span> <span class="toctext">Counting types; dependent dreams</span></a></li>
<li><a href="#Types_over_finite_sets"><span class="tocnumber">6</span> <span class="toctext">Types over finite sets</span></a></li>
</ul>
</div>
<h2 id="definitions"><span id="Definitions" class="mw-headline">Definitions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><span class="mw-editsection-bracket">]</span></span></h2>
<p>Fix some complete theory <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>T</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ec7200acd984a1d3a3d7dc455e262fbe54f7f6e0" class="mwe-math-fallback-image-inline" alt="{\displaystyle T}" /></span>, with monster model <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline">𝕌</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/35eecc86b49669c3d0da8692da4272d0b829f81a" class="mwe-math-fallback-image-inline" alt="{\displaystyle \mathbb {U} }" /></span>. A formula <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>x</em>; <em>y</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fca37e1328ca0b7c5cf92e2612ef9cc00378c0a" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (x;y)}" /></span> is said to <em>have the independence property</em> if there exist <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline">⟨<em>a</em><sub><em>i</em></sub>⟩<sub><em>i</em> ∈ ℕ</sub></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6e4cd2f352eb9e1bad1dca51f3e0d0911b9c01d7" class="mwe-math-fallback-image-inline" alt="{\displaystyle \langle a_{i}\rangle _{i\in \mathbb {N} }}" /></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline">⟨<em>b</em><sub><em>S</em></sub>⟩<sub><em>S</em> ⊂ ℕ</sub></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d0872e313a1dbd75cc28ca18de631b6df83f8e0c" class="mwe-math-fallback-image-inline" alt="{\displaystyle \langle b_{S}\rangle _{S\subset \mathbb {N} }}" /></span> such that for every <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>i</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/add78d8608ad86e54951b8c8bd6c8d8416533d20" class="mwe-math-fallback-image-inline" alt="{\displaystyle i}" /></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>S</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4611d85173cd3b508e67077d4a1252c9c05abca2" class="mwe-math-fallback-image-inline" alt="{\displaystyle S}" /></span>, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>i</em> ∈ <em>S</em> ⇔ 𝕌 ⊨ <em>ϕ</em>(<em>a</em><sub><em>i</em></sub>; <em>b</em><sub><em>S</em></sub>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/65acd0933325d86aaa2997cf5bf1a86c90e6f91a" class="mwe-math-fallback-image-inline" alt="{\displaystyle i\in S\iff \mathbb {U} \models \phi (a_{i};b_{S})}" /></span> Note that the variables <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>x</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" class="mwe-math-fallback-image-inline" alt="{\displaystyle x}" /></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>y</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b8a6208ec717213d4317e666f1ae872e00620a0d" class="mwe-math-fallback-image-inline" alt="{\displaystyle y}" /></span> could be tuples, and the location of the semi-colon matters.</p>
<p>A formula is said to be <em>NIP</em> if it does not have the independence property.</p>
<p>It turns out that the following conditions are equivalent:</p>
<ul>
<li>The formula <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>x</em>; <em>y</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fca37e1328ca0b7c5cf92e2612ef9cc00378c0a" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (x;y)}" /></span> has the independence property.</li>
<li>The formula <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em><sup>∨</sup>(<em>y</em>; <em>x</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5263333f6fd62f4aa17f45f47ad4ab86495c1311" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi ^{\vee }(y;x)}" /></span> has the independence property, where <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em><sup>∨</sup>(<em>y</em>; <em>x</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5263333f6fd62f4aa17f45f47ad4ab86495c1311" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi ^{\vee }(y;x)}" /></span> means <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>x</em>; <em>y</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fca37e1328ca0b7c5cf92e2612ef9cc00378c0a" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (x;y)}" /></span>.</li>
<li>For every finite sets <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>U</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/458a728f53b9a0274f059cd695e067c430956025" class="mwe-math-fallback-image-inline" alt="{\displaystyle U}" /></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>V</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/af0f6064540e84211d0ffe4dac72098adfa52845" class="mwe-math-fallback-image-inline" alt="{\displaystyle V}" /></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>R</em> ⊂ <em>U</em> × <em>V</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/03156128a7650875142142187b9cd15004c961be" class="mwe-math-fallback-image-inline" alt="{\displaystyle R\subset U\times V}" /></span>, there exist <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline">⟨<em>a</em><sub><em>u</em></sub>⟩<sub><em>u</em> ∈ <em>U</em></sub></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e253ffa3431099e1deeeb470817aef0b808593de" class="mwe-math-fallback-image-inline" alt="{\displaystyle \langle a_{u}\rangle _{u\in U}}" /></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline">⟨<em>b</em><sub><em>v</em></sub>⟩<sub><em>v</em> ∈ <em>V</em></sub></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ecd3b9ed9f5a1b491dc373e77643a5500b3daf66" class="mwe-math-fallback-image-inline" alt="{\displaystyle \langle b_{v}\rangle _{v\in V}}" /></span> such that <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>a</em><sub><em>u</em></sub>; <em>b</em><sub><em>v</em></sub>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c0aae89d49aa7e7ad21cbd409df6aa3b4a0b4d05" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (a_{u};b_{v})}" /></span> holds if and only if <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>u</em><em>R</em><em>v</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/380e7e4ea171a0ecbbb0a3116f3077c5d9b2609a" class="mwe-math-fallback-image-inline" alt="{\displaystyle uRv}" /></span>, for every <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>u</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3e6bb763d22c20916ed4f0bb6bd49d7470cffd8" class="mwe-math-fallback-image-inline" alt="{\displaystyle u}" /></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>v</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597" class="mwe-math-fallback-image-inline" alt="{\displaystyle v}" /></span>. So every bipartite graph can be embedded into the graph of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>x</em>; <em>y</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fca37e1328ca0b7c5cf92e2612ef9cc00378c0a" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (x;y)}" /></span>, in some sense.</li>
<li>There is an indiscernible sequence <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline">⟨<em>a</em><sub><em>i</em></sub>⟩<sub><em>i</em> &lt; <em>ω</em></sub></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d301121ea78c3823fc5c8f424282f1b8ddd5c7c0" class="mwe-math-fallback-image-inline" alt="{\displaystyle \langle a_{i}\rangle _{i&lt;\omega }}" /></span> and a <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>b</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f11423fbb2e967f986e36804a8ae4271734917c3" class="mwe-math-fallback-image-inline" alt="{\displaystyle b}" /></span> such that <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>a</em><sub><em>i</em></sub>; <em>b</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/48bb8bc363315145e7a51bb3fb89d4e85f9996c7" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (a_{i};b)}" /></span> holds if and only if <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>i</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/add78d8608ad86e54951b8c8bd6c8d8416533d20" class="mwe-math-fallback-image-inline" alt="{\displaystyle i}" /></span> is odd.</li>
</ul>
<p>A theory is said to be <strong>NIP</strong> if no formula has the independence property, i.e., every formula is NIP. A non-trivially equivalent condition is that every formula <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>x</em>; <em>y</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fca37e1328ca0b7c5cf92e2612ef9cc00378c0a" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (x;y)}" /></span> <em>with <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>x</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" class="mwe-math-fallback-image-inline" alt="{\displaystyle x}" /></span> a singleton</em> is NIP. That is, when checking NIP, one only needs to check formulas <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>x</em>; <em>y</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fca37e1328ca0b7c5cf92e2612ef9cc00378c0a" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (x;y)}" /></span> with <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>x</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" class="mwe-math-fallback-image-inline" alt="{\displaystyle x}" /></span> a singleton. This is a useful criterion when we have some control over one-dimensional definable sets, such as in the case of strongly minimal, o-minimal, or C-minimal theories.</p>
<h2 id="properties"><span id="Properties" class="mw-headline">Properties</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><span class="mw-editsection-bracket">]</span></span></h2>
<p>Like most classification-theoretic boundaries, NIP is preserved under adding imaginary sorts (passing to <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>M</em><sup><em>e</em><em>q</em></sup></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0ef067a0d350d5768ff1ad33b3b8f249c8878990" class="mwe-math-fallback-image-inline" alt="{\displaystyle M^{eq}}" /></span>), under reducts, and under naming parameters with new constant symbols.</p>
<p>Stable theories are NIP. In fact they are exactly the NIP theories which are also simple, or which are also NSOP.</p>
<p>Forking in NIP theories does not have many of the nice properties of forking in simple theories; for example, symmetry can fail, and forking can differ from dividing. However, it is still a useful tool. Here are some of the results on forking and dividing in NIP theories:</p>
<ul>
<li>Forking is equivalent to Lascar invariance: a global type <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>p</em>(<em>x</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8cb7afced134ef75572e5314a5d278c2d644f438" class="mwe-math-fallback-image-inline" alt="{\displaystyle p(x)}" /></span> forks (i.e., divides) over a base set <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>C</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fc55753007cd3c18576f7933f6f089196732029" class="mwe-math-fallback-image-inline" alt="{\displaystyle C}" /></span> if and only if it is Lascar invariant over <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>C</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fc55753007cd3c18576f7933f6f089196732029" class="mwe-math-fallback-image-inline" alt="{\displaystyle C}" /></span>. This can be expressed in two equivalent ways: (1) <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>p</em>(<em>x</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8cb7afced134ef75572e5314a5d278c2d644f438" class="mwe-math-fallback-image-inline" alt="{\displaystyle p(x)}" /></span> is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>M</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f82cade9898ced02fdd08712e5f0c0151758a0dd" class="mwe-math-fallback-image-inline" alt="{\displaystyle M}" /></span>-invariant for every model <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>M</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f82cade9898ced02fdd08712e5f0c0151758a0dd" class="mwe-math-fallback-image-inline" alt="{\displaystyle M}" /></span> containing <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>C</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fc55753007cd3c18576f7933f6f089196732029" class="mwe-math-fallback-image-inline" alt="{\displaystyle C}" /></span>; (2) for every <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>C</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fc55753007cd3c18576f7933f6f089196732029" class="mwe-math-fallback-image-inline" alt="{\displaystyle C}" /></span>-indiscernible sequence <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline">⟨<em>b</em><sub><em>i</em></sub>⟩<sub><em>i</em> ∈ <em>I</em></sub></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8d4569596402e9709c3eb7f2cf9af3190906caec" class="mwe-math-fallback-image-inline" alt="{\displaystyle \langle b_{i}\rangle _{i\in I}}" /></span> and formula <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>x</em>; <em>y</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fca37e1328ca0b7c5cf92e2612ef9cc00378c0a" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (x;y)}" /></span>, whether or not <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>x</em>; <em>b</em><sub><em>i</em></sub>) ∈ <em>p</em>(<em>x</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/647ebad8d7d5201f5488166a90169cfc47356adb" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (x;b_{i})\in p(x)}" /></span> does not depend on <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>i</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/add78d8608ad86e54951b8c8bd6c8d8416533d20" class="mwe-math-fallback-image-inline" alt="{\displaystyle i}" /></span>. This result was proven by Shelah or Adler or someone.</li>
<li>Forking is equivalent to KP invariance: a global type <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>p</em>(<em>x</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8cb7afced134ef75572e5314a5d278c2d644f438" class="mwe-math-fallback-image-inline" alt="{\displaystyle p(x)}" /></span> forks (i.e., divides) over a base set <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>C</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fc55753007cd3c18576f7933f6f089196732029" class="mwe-math-fallback-image-inline" alt="{\displaystyle C}" /></span> if and only if it is <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>b</em><em>d</em><em>d</em>(<em>C</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9e6bf387f6feaff3d3e0b20b0b73ba79115f9144" class="mwe-math-fallback-image-inline" alt="{\displaystyle bdd(C)}" /></span>-invariant. This was proven by Hrushovski and Pillay.</li>
<li>Forking and dividing agree over models, even on the level of formulas. That is, a formula <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>x</em>; <em>b</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b71bf21fbc5d1ffa6392528fae8e549dcf363d04" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (x;b)}" /></span> forks over a model <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>M</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f82cade9898ced02fdd08712e5f0c0151758a0dd" class="mwe-math-fallback-image-inline" alt="{\displaystyle M}" /></span> if and only if it divides over <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>M</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f82cade9898ced02fdd08712e5f0c0151758a0dd" class="mwe-math-fallback-image-inline" alt="{\displaystyle M}" /></span>. Moreover, in the o-minimal or c-minimal setting, one can replace "model" with "arbitrary set." These facts were proven by Chernikov and Kaplan (maybe building off the results of Hrushovski and Pillay, in the o-minimal and C-minimal setting).</li>
</ul>
<p>Some facts from stable group theory generalize to the NIP setting. For example, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>G</em><sup>00</sup></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/30cc72e3225470856ed0aed97bf4d1b15eb2ee42" class="mwe-math-fallback-image-inline" alt="{\displaystyle G^{00}}" /></span> always exists (the smallest type-definable subgroup of bounded index). This was proven by Shelah; a proof appears in a paper by Hrushovski, Peterzil, and Pillay. Maybe <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>G</em><sup>0</sup></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7c332d09499538333927fb909f9e38cfc991ada3" class="mwe-math-fallback-image-inline" alt="{\displaystyle G^{0}}" /></span> also exists, depending on what exactly <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>G</em><sup>0</sup></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7c332d09499538333927fb909f9e38cfc991ada3" class="mwe-math-fallback-image-inline" alt="{\displaystyle G^{0}}" /></span> means. But <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>G</em><sup>0</sup></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7c332d09499538333927fb909f9e38cfc991ada3" class="mwe-math-fallback-image-inline" alt="{\displaystyle G^{0}}" /></span> and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>G</em><sup>00</sup></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/30cc72e3225470856ed0aed97bf4d1b15eb2ee42" class="mwe-math-fallback-image-inline" alt="{\displaystyle G^{00}}" /></span> need not agree, unlike in the stable case. For example, if <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>G</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5f3c8921a3b352de45446a6789b104458c9f90b" class="mwe-math-fallback-image-inline" alt="{\displaystyle G}" /></span> is the circle group, or any compact definable group in RCF, then <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>G</em><sup>0</sup></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7c332d09499538333927fb909f9e38cfc991ada3" class="mwe-math-fallback-image-inline" alt="{\displaystyle G^{0}}" /></span> is the topological connected component of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>G</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5f3c8921a3b352de45446a6789b104458c9f90b" class="mwe-math-fallback-image-inline" alt="{\displaystyle G}" /></span>, while <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>G</em><sup>00</sup></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/30cc72e3225470856ed0aed97bf4d1b15eb2ee42" class="mwe-math-fallback-image-inline" alt="{\displaystyle G^{00}}" /></span> is the infinitesimal neighborhood of the origin.</p>
<p>Also, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>G</em><sup>000</sup></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fa4b67954d92054495ed9aeddaccee5a531e02ca" class="mwe-math-fallback-image-inline" alt="{\displaystyle G^{000}}" /></span> always exists; someone proved it, maybe.</p>
<p>A version of Baldwin-Saxl exists for NIP groups. It says that if <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>G</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5f3c8921a3b352de45446a6789b104458c9f90b" class="mwe-math-fallback-image-inline" alt="{\displaystyle G}" /></span> is a type-definable group in an NIP theory, and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>x</em>; <em>y</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fca37e1328ca0b7c5cf92e2612ef9cc00378c0a" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (x;y)}" /></span> is a formula, then there is an integer <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>n</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" class="mwe-math-fallback-image-inline" alt="{\displaystyle n}" /></span> such that any finite intersection of relatively definable subgroups cut out by <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>x</em>; <em>y</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fca37e1328ca0b7c5cf92e2612ef9cc00378c0a" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (x;y)}" /></span> is an intersection of at most <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>n</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" class="mwe-math-fallback-image-inline" alt="{\displaystyle n}" /></span> of them.</p>
<h2 id="generically-stable-types"><span id="Generically_stable_types" class="mw-headline">Generically stable types</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><span class="mw-editsection-bracket">]</span></span></h2>
<p>In NIP theories, there is a well-defined notion of generically stable types, which have many of the properties of types in stable theories. A global <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>C</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fc55753007cd3c18576f7933f6f089196732029" class="mwe-math-fallback-image-inline" alt="{\displaystyle C}" /></span>-invariant type is said to be <strong>generically stable</strong> if it satisfies one of the following equivalent conditions:</p>
<ul>
<li>The type <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>p</em>(<em>x</em><sub>1</sub>) ⊗ <em>p</em>(<em>x</em><sub>2</sub>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/176ef4940d2dc5863ecd4d186ffbcb8f10c33ef7" class="mwe-math-fallback-image-inline" alt="{\displaystyle p(x_{1})\otimes p(x_{2})}" /></span> equals <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>p</em>(<em>x</em><sub>2</sub>) ⊗ <em>p</em>(<em>x</em><sub>1</sub>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b38da2d36268bf1293e7acba5a87b0f81884cf66" class="mwe-math-fallback-image-inline" alt="{\displaystyle p(x_{2})\otimes p(x_{1})}" /></span>.</li>
<li>For every global invariant type <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>q</em>(<em>y</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/46049a30deb0e2a1d751cab6457c5204d7ee82a9" class="mwe-math-fallback-image-inline" alt="{\displaystyle q(y)}" /></span>, we have <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>p</em>(<em>x</em>) ⊗ <em>q</em>(<em>y</em>) = <em>q</em>(<em>y</em>) ⊗ <em>p</em>(<em>x</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0b55d667ba14593651f1eeb68e40f4e52c92ea7a" class="mwe-math-fallback-image-inline" alt="{\displaystyle p(x)\otimes q(y)=q(y)\otimes p(x)}" /></span>.</li>
<li>The Morley sequence of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>p</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/81eac1e205430d1f40810df36a0edffdc367af36" class="mwe-math-fallback-image-inline" alt="{\displaystyle p}" /></span> is totally indiscernible (over the empty set)</li>
<li><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>p</em>(<em>x</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8cb7afced134ef75572e5314a5d278c2d644f438" class="mwe-math-fallback-image-inline" alt="{\displaystyle p(x)}" /></span> is definable, and finitely satisfiable in some small set.</li>
<li><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>p</em>(<em>x</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8cb7afced134ef75572e5314a5d278c2d644f438" class="mwe-math-fallback-image-inline" alt="{\displaystyle p(x)}" /></span> is definable, and finitely satisfiable in every small model containing <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>C</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fc55753007cd3c18576f7933f6f089196732029" class="mwe-math-fallback-image-inline" alt="{\displaystyle C}" /></span> (todo: check this condition)</li>
<li> [Voting by Morley sequences…]</li>
<li>For every <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>B</em> ⊇ <em>C</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/bac3c53023dafdde64fb1d693b97a56f3abf67ec" class="mwe-math-fallback-image-inline" alt="{\displaystyle B\supseteq C}" /></span>, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>p</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/81eac1e205430d1f40810df36a0edffdc367af36" class="mwe-math-fallback-image-inline" alt="{\displaystyle p}" /></span> is the unique non-forking extension of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>p</em>|<em>B</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e1ed521bb24702198b0081d4c5bdaec22b54b298" class="mwe-math-fallback-image-inline" alt="{\displaystyle p|B}" /></span>.</li>
</ul>
<p>In light of the last bullet point, it makes sense to say that a complete type <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>p</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/81eac1e205430d1f40810df36a0edffdc367af36" class="mwe-math-fallback-image-inline" alt="{\displaystyle p}" /></span> over a set <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>C</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fc55753007cd3c18576f7933f6f089196732029" class="mwe-math-fallback-image-inline" alt="{\displaystyle C}" /></span> is generically stable: this means that <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>p</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/81eac1e205430d1f40810df36a0edffdc367af36" class="mwe-math-fallback-image-inline" alt="{\displaystyle p}" /></span> is stationary, and the unique nonforking global extension of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>p</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/81eac1e205430d1f40810df36a0edffdc367af36" class="mwe-math-fallback-image-inline" alt="{\displaystyle p}" /></span> is generically stable.</p>
<p>Even outside of the NIP setting, there is a notion of a generically stable type, but it is much more constrained, and the above equivalences fail.</p>
<p>Generically stable types are equivalent to stably dominated types in ACVF, and play an important role there. But there are many theories, such as RCF and <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>p</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/81eac1e205430d1f40810df36a0edffdc367af36" class="mwe-math-fallback-image-inline" alt="{\displaystyle p}" /></span>-adically closed fields, in which all generically stable types are trivial. In these settings, one must instead look at generically stable <em>measures</em>…</p>
<h2 id="keisler-measures"><span id="Keisler_measures" class="mw-headline">Keisler measures</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><span class="mw-editsection-bracket">]</span></span></h2>
<p>"Smooth measures" exist.</p>
<p>Also, all measures are Borel type-definable.</p>
<h2 id="counting-types-dependent-dreamscounting_types_dependent_dreams-.mw-headline"><span id="Counting_types.3B_dependent_dreams"></span>[Counting types; dependent dreams]{#Counting_types;_dependent_dreams .mw-headline}<span class="mw-editsection"><span class="mw-editsection-bracket">[</span><span class="mw-editsection-bracket">]</span></span></h2>
<p>If <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>κ</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/54ddec2e922c5caea4e47d04feef86e782dc8e6d" class="mwe-math-fallback-image-inline" alt="{\displaystyle \kappa }" /></span> is a cardinal, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>d</em><em>e</em><em>d</em>(<em>κ</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f9a8240c9cd5eff2ccdc1823ca03ca3ef06e7a7e" class="mwe-math-fallback-image-inline" alt="{\displaystyle ded(\kappa )}" /></span> is something like the supremum of cardinals <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>λ</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b43d0ea3c9c025af1be9128e62a18fa74bedda2a" class="mwe-math-fallback-image-inline" alt="{\displaystyle \lambda }" /></span> such that there is a linear order of cardinality <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>κ</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/54ddec2e922c5caea4e47d04feef86e782dc8e6d" class="mwe-math-fallback-image-inline" alt="{\displaystyle \kappa }" /></span> which has at least <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>λ</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b43d0ea3c9c025af1be9128e62a18fa74bedda2a" class="mwe-math-fallback-image-inline" alt="{\displaystyle \lambda }" /></span>-many Dedekind cuts. Under some set-theoretic assumptions, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>d</em><em>e</em><em>d</em>(<em>κ</em>) = 2<sup><em>κ</em></sup></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fd27fdbd4b713dc43921a8665a115dc3777f392f" class="mwe-math-fallback-image-inline" alt="{\displaystyle ded(\kappa )=2^{\kappa }}" /></span> for every <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>κ</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/54ddec2e922c5caea4e47d04feef86e782dc8e6d" class="mwe-math-fallback-image-inline" alt="{\displaystyle \kappa }" /></span>, though under other set-theoretic assumptions, one has <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>d</em><em>e</em><em>d</em>(<em>κ</em>) &lt; 2<sup><em>κ</em></sup></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/919c124cdb4557a1bd321d30cf52b9e9a7eca14d" class="mwe-math-fallback-image-inline" alt="{\displaystyle ded(\kappa )&lt;2^{\kappa }}" /></span> for some <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>κ</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/54ddec2e922c5caea4e47d04feef86e782dc8e6d" class="mwe-math-fallback-image-inline" alt="{\displaystyle \kappa }" /></span>. At any rate, ZFC does not decide the matter.</p>
<p>Shelah proved (something like) the following result:</p>
<ul>
<li>If <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>T</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ec7200acd984a1d3a3d7dc455e262fbe54f7f6e0" class="mwe-math-fallback-image-inline" alt="{\displaystyle T}" /></span> is NIP, then the number of types over a set of size <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>κ</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/54ddec2e922c5caea4e47d04feef86e782dc8e6d" class="mwe-math-fallback-image-inline" alt="{\displaystyle \kappa }" /></span> is at most <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>d</em><em>e</em><em>d</em>(<em>κ</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f9a8240c9cd5eff2ccdc1823ca03ca3ef06e7a7e" class="mwe-math-fallback-image-inline" alt="{\displaystyle ded(\kappa )}" /></span>, for (some/all/sufficiently large?) <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>κ</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/54ddec2e922c5caea4e47d04feef86e782dc8e6d" class="mwe-math-fallback-image-inline" alt="{\displaystyle \kappa }" /></span>.</li>
<li>If <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>T</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ec7200acd984a1d3a3d7dc455e262fbe54f7f6e0" class="mwe-math-fallback-image-inline" alt="{\displaystyle T}" /></span> is not NIP, then for every <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>κ</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/54ddec2e922c5caea4e47d04feef86e782dc8e6d" class="mwe-math-fallback-image-inline" alt="{\displaystyle \kappa }" /></span> there is a set of size <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>κ</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/54ddec2e922c5caea4e47d04feef86e782dc8e6d" class="mwe-math-fallback-image-inline" alt="{\displaystyle \kappa }" /></span> such that there are <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline">2<sup><em>κ</em></sup></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/77935d198ec4eba3fe76ff33e61be86b9525eb56" class="mwe-math-fallback-image-inline" alt="{\displaystyle 2^{\kappa }}" /></span>-many types over said set.</li>
</ul>
<p>Consequently, one can characterize NIP theories (in some models of ZFC) by a type-counting description, in the same way that one can characterize stable theories by counting types.</p>
<p>Wait, maybe the above result was for <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>x</em>; <em>y</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fca37e1328ca0b7c5cf92e2612ef9cc00378c0a" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (x;y)}" /></span> types, where <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>x</em>; <em>y</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fca37e1328ca0b7c5cf92e2612ef9cc00378c0a" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (x;y)}" /></span> is a NIP or non-NIP formula…</p>
<p>(Historical note: the original proof that NIP could be checked on formulas <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>x</em>; <em>y</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fca37e1328ca0b7c5cf92e2612ef9cc00378c0a" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (x;y)}" /></span> with <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>x</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" class="mwe-math-fallback-image-inline" alt="{\displaystyle x}" /></span> a singleton, was using this criterion?)</p>
<h2 id="types-over-finite-sets"><span id="Types_over_finite_sets" class="mw-headline">Types over finite sets</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><span class="mw-editsection-bracket">]</span></span></h2>
<p>NIP formulas can be characterized by counting types over <em>finite</em> sets. If <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>x</em>; <em>y</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fca37e1328ca0b7c5cf92e2612ef9cc00378c0a" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (x;y)}" /></span> is a formula, consider the function <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>f</em> : ℕ → ℕ</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/dfa847e103c9e2e5075b1b510f67aad8ceae9349" class="mwe-math-fallback-image-inline" alt="{\displaystyle f:\mathbb {N} \to \mathbb {N} }" /></span> which maps <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>n</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" class="mwe-math-fallback-image-inline" alt="{\displaystyle n}" /></span> to the maximum number of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi }" /></span>-types over a set of size <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>n</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" class="mwe-math-fallback-image-inline" alt="{\displaystyle n}" /></span>. The <strong>Sauer-Shelah lemma</strong> says that one of two things happens:</p>
<ul>
<li><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>f</em>(<em>n</em>) = 2<sup><em>n</em></sup></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/bb2a11c95bfafd14ee7722bb23f67ed8dc90b6c4" class="mwe-math-fallback-image-inline" alt="{\displaystyle f(n)=2^{n}}" /></span> for every <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>n</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" class="mwe-math-fallback-image-inline" alt="{\displaystyle n}" /></span>, in which case <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>x</em>; <em>y</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fca37e1328ca0b7c5cf92e2612ef9cc00378c0a" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (x;y)}" /></span> has the independence property.</li>
<li><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>f</em>(<em>n</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c1c49fad1eccc4e9af1e4f23f32efdc3ac4da973" class="mwe-math-fallback-image-inline" alt="{\displaystyle f(n)}" /></span> grows polynomially, in which case <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>x</em>; <em>y</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fca37e1328ca0b7c5cf92e2612ef9cc00378c0a" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (x;y)}" /></span> is NIP.</li>
</ul>
<p>It is conjectured that the polynomial growth can be witnessed by a uniform definability of types over finite sets. Specifically, it is conjectured that if <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>x</em>; <em>y</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fca37e1328ca0b7c5cf92e2612ef9cc00378c0a" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (x;y)}" /></span> is an NIP formula, then there is some formula <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ψ</em>(<em>y</em>; <em>y</em><sub>1</sub>, …, <em>y</em><sub><em>n</em></sub>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2ee62c2bc6bc7ec8f5a59f3a35cec9cb2632b485" class="mwe-math-fallback-image-inline" alt="{\displaystyle \psi (y;y_{1},\ldots ,y_{n})}" /></span> such that for every finite set <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>A</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7daff47fa58cdfd29dc333def748ff5fa4c923e3" class="mwe-math-fallback-image-inline" alt="{\displaystyle A}" /></span> and every <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi }" /></span>-type <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>p</em>(<em>x</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8cb7afced134ef75572e5314a5d278c2d644f438" class="mwe-math-fallback-image-inline" alt="{\displaystyle p(x)}" /></span> over <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>A</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7daff47fa58cdfd29dc333def748ff5fa4c923e3" class="mwe-math-fallback-image-inline" alt="{\displaystyle A}" /></span>, there exist <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>b</em><sub>1</sub>, …, <em>b</em><sub><em>n</em></sub> ∈ <em>A</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/105f0ab89acc6574e9a9a0f8a6e3ab1b503d6dfa" class="mwe-math-fallback-image-inline" alt="{\displaystyle b_{1},\ldots ,b_{n}\in A}" /></span> such that for <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>b</em> ∈ <em>A</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/26329067b4b3630a2bb6f7e6b3ee367b70918371" class="mwe-math-fallback-image-inline" alt="{\displaystyle b\in A}" /></span>, the formula <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em>(<em>x</em>; <em>b</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b71bf21fbc5d1ffa6392528fae8e549dcf363d04" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi (x;b)}" /></span> is in <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>p</em>(<em>x</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8cb7afced134ef75572e5314a5d278c2d644f438" class="mwe-math-fallback-image-inline" alt="{\displaystyle p(x)}" /></span> if and only if <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ψ</em>(<em>b</em>; <em>b</em><sub>1</sub>, …, <em>b</em><sub><em>n</em></sub>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a2ff33a66b93c22e2624426ff60afb34e2bfb06e" class="mwe-math-fallback-image-inline" alt="{\displaystyle \psi (b;b_{1},\ldots ,b_{n})}" /></span> holds. So <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ψ</em>(−;<em>b</em><sub>1</sub>, …, <em>b</em><sub><em>n</em></sub>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/95615690014566216eb4770e128ec3c88d57397e" class="mwe-math-fallback-image-inline" alt="{\displaystyle \psi (-;b_{1},\ldots ,b_{n})}" /></span> is the <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>ϕ</em></span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4" class="mwe-math-fallback-image-inline" alt="{\displaystyle \phi }" /></span>-definition of <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><span class="math inline"><em>p</em>(<em>x</em>)</span></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8cb7afced134ef75572e5314a5d278c2d644f438" class="mwe-math-fallback-image-inline" alt="{\displaystyle p(x)}" /></span>. Of course any type over a finite set is definable over that set, but the conjecture is that the definition can be chosen uniformly across all finite sets. This conjecture turns out to be equivalent to a conjecture in machine learning.</p>
<p><em>The conjecture is known in the case when the ambient theory is NIP</em>, i.e., when <em>all</em> formulas are NIP. This was proven by… ::: ::: :::</p>
