#! https://zhuanlan.zhihu.com/p/408789743

*由L. T. F. Kanud of Vihara译出(译：cjy、校：虎猫(第一节到第三节)，羽川翼(第四节))
曾载于豆瓣：https://www.douban.com/note/785070154/ 

*作者Neil Immerman (immerman@cs.umass.edu)是马萨诸塞大学的一位理论计算机科学家，1995年哥德尔奖获得者，描述复杂性(descriptive complexity)理论的主要开发者之一。

*参考文献部分请参原文: https://plato.stanford.edu/entries/computability/#Bib

*本文是一篇关于，图灵机，丘奇-图灵论题，递归可枚举，递归函数等关键概念，与计算理论中的可计算性理论及计算复杂性理论的，简单而优秀的科普。上面给出了有进一步专门词条的超链接，有兴趣的或许可做进一步阅读。

*First published Thu Jun 24, 2004; substantive revision Wed Sep 2, 2015*

一个数学问题是可计算的(computable)，当其原则上是可由一个计算手段解决的(computing devices)。关于“可计算的”的一些常见同义词是，“可解的(solvable)”，“可判定的(decidable)”，“递归的(recursive)”。希尔伯特相信所有数学问题都是可解的，但是在1930年代，哥德尔，图灵，丘奇，表明事实并不如此。而这里就会有一个广泛的研究与分类是关于，哪些数学问题是可计算的，而哪些不是。另外，根据这个问题的计算量，有一个广泛的分类，将可计算的问题分为到不同的计算复杂性类(computational complexity classes)中，而计算量指，需要多少计算去回答问题的实例，根据于该问题实例的大小。令人惊讶的是，被描绘出的这些分类是如此的清晰，优雅与精确。

<br/>

目录
•	1. What can be computed in principle? Introduction and History

•	2. Turing Machines

o	2.1 Universal Machines

o	2.2 The Halting Problem

o	2.3 Computable Functions and Enumerability

o	2.4 The Unsolvability of the Halting Problem

•	3. Primitive Recursive Functions

o	3.1 Recursive Functions

•	4. Computational Complexity: Functions Computable in Practice

o	4.1 Significance of Complexity

•	Bibliography

•	Academic Tools

•	Other Internet Resources

•	Related Entries

<br/><br/>

1.	What can be computed in principle? Introduction and History

在1930年代，也就是远在计算机被发明出来之前,世界各地的数学家发现了关于，“什么是可计算的”这个东西的，精确与独立的定义。丘奇定义了lambda演算(lambda calculus)。哥德尔定义了递归函数(recursive functions)。斯蒂芬克莱尼定义了形式系统(formal systems)。马尔可夫定义了被人们熟知的马尔可夫算法(Markov algorithms)，波斯特与图灵定义了现在被人们熟知的波斯特-图灵机(Post machines and Turing machines)的抽象的机器。

令人惊奇的是，所有这些模型都是精确相等的：所有在lambda演算中是可计算的，在图灵机中也是，并且对于上述所有系统的其他对子来说也都是如此。在此被证明之后，丘奇表示，“原则上可计算”这个直观概念，可以被定义为上述的精确概念。这个信念，现在被称作丘奇-图灵论题(Church-Turing Thesis)，并被数学家们统一接受。

编纂什么是可计算的，的部动力来自于数学家大卫希尔伯特。希尔伯特相信，所有数学都能被精确地公理化(axiomatized)。他认为，一旦做到这一点，我们就将有一个“能行的程序(effective procedure)”，即，一种算法，它将任何一个精确的数学陈述作为输入，经过有限步之后，决定这个数学陈述是正确的还是错误的。希尔伯特现在要的就是，对所有的数学去进行判定的这样一个判定程序(decision procedure)。

作为判定问题的一个特殊的例子，希尔伯特考虑了一阶逻辑的有效性问题(validity problem)，一阶逻辑是一个可以形式化大多数数学陈述的数学语言。任何一个一阶逻辑中的陈述，在任意适合的逻辑结构中，都有一个精确的意义，即，其在任何一个这样的结构中，要么为真要么为假。那些在所有适合的结构中都为真的陈述被称为有效的。那些在某个结构中为真的陈述被称为*可满足的(satisfiable)*。注意，一个公式$φ$是有效的，当且仅当，其否定$¬φ$是不可满足的。

希尔伯特将一阶逻辑的有效性问题称为*判定问题(entscheidungsproblem)*。在一本希尔伯特与阿克曼所著的教科书上(Principles of Mathematical Logic)有这样写道，“当我们掌握了一个程序，其允许，在有限步的运算中能够判定，任何被给定的逻辑表达式是有效的或者可满足的时，我们就解决了判定问题……而判定问题必须被考虑作数理逻辑的主要问题” (Böerger, Grädel, & Gurevich 1997)。

哥德尔在他1930年的博士论文中，基于罗素与怀特海的《数学原理》(*Principia Mathematica*)，提出了一阶逻辑的完全公理化。哥德尔证明了他的完全性定理(Completeness Theorem)，即， 一个式子是可由公理证明的，当且仅当其是有效的。哥德尔的完全性定理跨出了朝向解决希尔伯特判定问题的一步。

特别地，由于公理很好辨别并且推理规则也很简单，我们就将会有一个机械化程序可以列出所有的证明。注意，在证明中，每一行，要么是公理，要么是经由其中一个推理规则从前面的行中所推出的。对于任何给定的字符串，我们都可以辨别其是否是一个证明。这样，我们便可系统性地列出所有长度为1，2，3等等的符号串，然后检查它们是否是一个证明。如果是，那么我们就可以将证明中的最后一列加入到，定理的列表中。这样，我们便可列出所有证明，即，通过一个简单的机械化程序，能准确地列出所有一阶逻辑的有效式。更精确地说，有效式的集，就是可计算函数(computable function)的值域。用当代的术语来说就是，一阶逻辑有效式的集是，*递归可枚举的(recursively enumerable(r.e.))*

然而，哥德尔完全性定理对于给出一个判定问题的明确解答来说并不充分。给定一个式子，φ，如果φ是有效的，那么上述程序最终将会列出它，并且给出“是，φ是有效的”这样一个答案。然而，如果φ不是有效的，我们可能终究都不会得到这个事实。现在缺少的就是一个程序，去列出所有非有效式，或者等价地去列出所有可满足的式子。

一年后，也就是1931年，哥德尔提出了他的不完备性定理(Incompleteness Theorem)震惊了整个数学界：我们没有完全的且可计算的，关于自然数的一阶理论的公理化。这意味着，没有这样一个合理的列表，我们可以从中准确地证明出所有数论中的真命题(Gödel 1931).。

几年之后，丘奇与图灵独立证明了判定问题是不可解的。丘奇通过运用哥德尔不完备性定理中的手段，展示了，一阶逻辑的可满足的公式集不是递归可枚举的，即，它们不可被系统化地，经lambda演算的可计算函数列出。图灵引入了他的机器，并证明了许多我们将在下一节中会讨论到的有趣定理。特别地，他证明了停机问题(halting problem)是不可解的。同时作为推论，他也得到了判定问题同样也是不可解的。

希尔伯特非常失望，因为他的计划，关于所有数学判定程序，被证明为是不可能的。然而，如我们将要看到的那样，我们将会学到大量关于计算的基础性质的知识。

<br/>

2. Turing Machines
   
在图灵1936年的论文(On Computable Numbers, with an Application to the Entscheidungsproblem)中，他引入了这个机器，并奠定了它们的基本性质。

他清晰而理论性地给出了什么是，机器执行计算任务，的意义。图灵如下定义了他的机器：
- 一个有限的可能状态集$Q$，因为任何设备都必须处在，有限的可能状态的其中一个之下。

- 一个潜无穷的磁带，其由单元格$σ_1,σ_2,σ_3$组成，它们来自于某个有限字母表$Σ$；($Σ$可以是包含至少两个符号的任意有限集。出于方便，可以固定$Σ=\{0,1,b\}$ ，即该字母表包含二进制字母再加上空白单元符。我们通常假设磁带的有限初始段包含二进制符号，而余下部分则为空白。)
- 一个磁带读写探头，$h≥1$，扫描磁带的单元格$σ_h$；以及最后，
- 一个转换函数，$δ:Q×Σ→Q×Σ×\{-1,0,1\}$。(这个转换函数的意思是，从任意给定状态$q$，以及读取到的任意给定的符号，$σ_h, δ$告诉我们机器应该进入的新状态，应被记在当前方格中的新符号，以及下一个探头位置，$h'=h+d$，其中$d∈\{-1,0,1\}$是由$δ$给出的位移。)

与内存(随机存取存储器，random access memory)相比，存储磁带的线性性质是一个对运算速度的限制，但并没有限制其运算力：图灵机可以寻找到任意存储位置，即，磁带单元格，只是这可能会花些时间，因为其必须一步步地沿着磁带移动其探头。

图灵机的美妙之处在于，这是一个极其简单的模型，然而运算力却十分强大。图灵机具有潜无穷的工作空间，使其能够处理任意大的输入，比如，两个大数相乘，然而其每一步只能读取或者记录有限量的信息，即，一个符号。甚至在图灵机被证明，与其他关于计算的数学模型等价之前，以及丘奇图灵论题被表述之前，图灵就令人信服地表明了，他的机器和其他任何可能的计算设备一样强大。

<br/>

2.1 Universal Machines

每一台图灵机都可以被唯一地描述为其转换表：对每一个状态$q$，以及每一个符号，$σ,δ(q,σ)$是一个新状态，新符号，以及探头位移。这些转换表可以被记作有限的符号串，以给出了每一台图灵机的完整指令集。进一步，这些符号串可以被如下地以词典顺序列出，$M_1,M_2,M_3…$，在这里$M_i$是转换表，即，完整指令集，对每个图灵机编号$i$，转换表$M_i$就是图灵机的程序，或者更准确地说是$i^{th}$的程序。

图灵展示了他可以构造一台*通用的(universal)*图灵机，U，其可以运行任何其他图灵机的程序。更明确地，对于任意i，以及任意输入w，U在输入i与w时，将完全按照M_i在输入w时那样运行，用符号表示就是，
$U(i,w)=M_i (w)$

图灵对通用机的构造给我们了一个关于计算的最基础性的启示，一台机器就能运行其他任何程序。无论我们需要在未来执行什么样的计算任务，仅需一台机器就能够执行所有它们。图灵的这个见解使得搭建与销售计算机成为可能。一台计算机就能运行所有程序。我们不需要在要解决新任务的时候每次都买台新计算机。当然，在个人电脑的时代，这个事实已是个基本假定，以至于我们很难退后一步去重新审视它。

<br/>

2.2 The Halting Problem

因为其被设计出来去体现所有可能的计算，图灵机有一个不可避免的缺陷，图灵机进行某些输入后将永远不会停机。其不能停机的某些原因十分愚蠢，比如我们可以对图灵机做出一个错误的编程，致使其进入一个紧凑循环(tight loop)，例如，在状态$17$中若读取到$1$，其可能会进入状态$17$并写下$1$，然后将探头移到$0$。不那么傻的是，我们可以到达一个空白符，其右边也全是空白符，同时也保持一直处在同一个状态——向右移动一格寻找一个$“1”$。这两个不能停机的例子，都可以被一个像样的编译器简单地检测到与修正。然而，考虑图灵机$M_F$，输入$“0”$并系统性地搜索费马大定理(Fermat's last theorem)的第一个反例，当找到它时便输出这个反例并停机。而这直到最近安德鲁·怀尔斯(Andrew Wiles)证明了费马大定理之前，所有数学家工作了超过三个世纪都没能决定，$M_F$输入$0$后，最终是否停机。现在我们知道了它永远不会停。

<br/>

2.3 	Computable Functions and Enumerability

既然图灵机在一定输入上可能不会停机，那么我们对于如何通过图灵机来定义可计算函数上便必须十分小心。让自然数N为一个集合 $\{0,1,2,…\}$，并让我们把图灵机考虑作一个从$N$到$N$的部分函数

设$M$为一台图灵机，$n$为一个自然数，我们称$M$的磁带包含数字$n$，当，$M$的磁带以一个数的二进制表达开始(没有不必要的前导$0$)，而在这之后全是空白。

如果我们将图灵机$M$开始于含有$n$的磁带上，而它最终停机时，磁带含有$m$，则我们说$M$在输入$n$时计算出$m：M(n)=m$。如果我们将$M$开始于输入$n$，而它或者不能停机，或者停机时，不含有一个自然数，比如它含有$0$或是中间有空白符，那么我们便说$M(n)$是未定义的(undefined)，用符号表达为： $M(n)=↗$。如此，我们便可为每个图灵机$M$关联一个部分函数，$M:N→N∪\{↗\}$ 。我们说这个函数$M$是全函数，当，对于所有$n∈N，M(n)∈N$，即$M(n)$总是被定义的时。

现在我们便可形式化地定义，再之前非形式化描述过的，递归可枚举。若$S⊆N$，而$S$是递归可枚举的，当且仅当，我们有某个图灵机M，其使得S是经由M计算的函数的像，符号地，
$S=\{M(n)∣n∈N;M(n)≠↗\}$

这样，$S$是递归可枚举的，仅当，它可以被某个图灵机列出。若$S$是递归可枚举的，且其元素可由图灵机$M$像上面那样列举出来。这样，我们就可以描述另一个图灵机$P$，其在输入$n$时，以循环的方式运行图灵机M与其所有可能的输入，直到最终输出$n$。如果这发生了，那么$P$停机，并输出$“1”$，即，$P(n)=1$，如果$n∉S$，那么，$M$将永远不会输出$n$所以$P(n)$也永远不会停机，即$P(n)=↗$。

设$P(n)↓$意味着，图灵机$P$在输入$n$时，最终能够停机。对于一个图灵机$P$，定义$L(P)$，即$P$所接受的集合为，那些当输入进P而P能最终停机的，
$L(P)=\{n∣P(n)↓\}$

上述论证表明，如果一个集合$S$是递归可枚举的，那么其可以被图灵机$P$接受，即$S=L(P)$。这个式子的逆同样也成立。这样，$S$是递归可枚举的，当且仅当，它能被某个图灵机$P$所接受。

我们说一个集合$S$是可判定的，当且仅当，有一个全图灵机$M$，其可以判定，对于所有的$n∈N$，是否有$n∈S$，把值$“1”$作为是，$“0”$则为不是。对于所有$n∈N$，如果$n∈S$，则$M(n)=1$，即，$M$在输入$n$上最终停机，并输出“是”，而如果$n∉S$，则$M(n)=0$，即$M$在输入$n$上最终停机，并输出“否”。关于可判定的同义词是，可计算的，可解的，递归的。

对于$S⊆N$，$S$的补便是$N-S$，即，所有不在$S$中的自然数的集。我们说集合$S$是*共递归可枚举的(co-r.e.)*，当且仅当，其补是递归可枚举的且共递归可枚举的，然后我们可以在第一列中列出所有它的元素，而在第二列中列出所有它的非元素。通过这样的方式，我们可以判定，给定元素$n$，是否属于$S$，这只需要浏览一下这两行然后等着$n$出现就行了。如果其出现在第一行，那么$n∈S$，反之出现在第二行，就是$n∉S$。事实上，一个集合是递归的，当且仅当，它是递归可枚举的且共递归可枚举的。

<br/>

2.4 	The Unsolvability of the Halting Problem

图灵问到，对于所有自然数集来说是否其都是可判定的。通过下面的计数论证，我们非常容易地就能知道答案是否定的。N有不可数数量的子集，但由于我们只有可数数量的图灵机，所以也只有可数数量的集合是可判定的。那么最后就是，多数集合都是不可判定的。

图灵实际上构造了一个不可判定集。如我们将看到的那样，他是通过运用对角线法(diagonal argument)来做到的。对角线法可以追溯到康托尔用其去表明实数是不可数的。哥德尔在他对不完备性定理的证明中，也用了一个相似的对角线法，他在数论中构造了这样一个句子$J$，这个句子的意思是，它本身不可证。

图灵如下地构造了一个对角线式停机集$K$：
$K=\{n∣M_n (n)↓\}$.
这是指$K$由那些，输入它们自己的程序后最终会停机的图灵机所组成。

不难看到，$K$是递归可枚举的。为了构造矛盾，假设，$K$也是共递归可枚举的，并让$d$为接受$K$的元素的一台图灵机的数。这样，对于任何$n$，
$n∉K⇔M_d (n)↓$

但考虑一下，当我们在上面用$d$代替$n$时会发生些什么：
$d∉K⇔M_d (n)↓$

但$K$的定义告诉我们，
$d∈K⇔M_d (d)↓$.

这样，我们就有了，
$d∈K⇔d∉K$

而这是一个矛盾，因此，我们对$K$是共递归可枚举的假设是错误的。也因此，K将不是递归的。这可以推出，对于一个给定的图灵机及其输入，并判定其最终是否能够停机的问题来说，这不是一个可计算问题，即，停机问题是不可解的。(译注：最先的定义告诉我们$d$属于$K$等价于$M_d$输入$d$时停机，但因为，$K$是递归可枚举且共递归可枚举的，所以对于任何数$n$都可以使$M$停机而不管是其是否属于$K$，而当我们将$d$代到其不属于$K$的$n$的情况下时，其当然也可以停机，并等价推出$d∈K$，这样就出现了矛盾)

<br/>

3. 	Primitive Recursive Functions

我们接下来定义*原始递归函数(primitive recursive functions)*的类(class)。这是一个非常有有意思的函数类，其由Skolem (1923)给出，并被哥德尔运用到了他对不完备性定理的证明中。我们关注于从$N^r$到$N$的函数$f$，对于$r=0,1,2,…$，我们称$r$为函数$f$的元数，即其中变元的数目。哥德尔从三个非常简单的函数开始，初始函数，以及两个自然闭包运算，合成(composition)与原始递归，它们中都每一个都使用某个已经被定义好的函数，然后去定义一个新函数。下面我们将细节性地解释一下他的定义。这节将比较技术化，你跳过了也没啥关系。关键思想是，原始递归函数由一个非常大且强有力的可计算函数类组成，并且所有它们都以非常简单的方式被生成出来。

我们从三个初始的原始递归函数开始：
- $ζ$为，元数$0$的零函数(zero function)，$ζ( ) =0$；
- $η$为，元数$1$的恒等函数(identity function)，$η(n)=n$；以及
- $σ$为，元数$1$的后继函数(successor function)，$σ(n)=n+1$。

然后考虑下面两个运算：
- **Composition**：如果$f$是一个元数$a$的原始递归函数, 以及$g_1,…,g_a$为元数$r_1,…,r_a$的原始递归函数, 并且$k∈N$，那么下面是一个元数$k$的原始递归函数：
  
&emsp; $h(x_1,…,x_k)=f(g_1 (w_1),…,g_a (w_a))$

在其中，每个$w_i$为，$r_i$变元的一个列表，来自于$x_1,…,x_k$，并或许包含重复。

- **Primitive recursion**：如果$f$与$g$各自地为，元数$k$与$k+2$的原始递归函数，那么我们有一个元数$k+1$的原始递归函数$h$，其满足下面的条件: 
  
&emsp; $h(0,x_1,…,x_k )=f(x_1,…,x_k )$；以及，

&emsp; $h(n+1,x_1,…,x_k)=g(h(n,x_1,…,x_k),n,x_1,…,x_k)$。

在这里，合成是一种非常自然的方式以去合并函数，而原始递归函数是一种有限制的递归，其中第一个变元为$n+1$的$h$根据，第一个变元为n的h来定义，而所有其他变元保持不变。

定义原始递归函数为，包含初始函数以及在合成与原始递归运算下闭合的函数的，最小类。原始递归函数的集等同于，使用有界迭代(bounded iteration)计算的函数的集(Meyer & Ritchie 1967)，即，在BlooP语言中可定义的函数集，这来自于(Hofstadter 1979)
原始递归函数有着非常简单的定义但却非常强大。哥德尔归纳性地证明了每个原始递归函数都可被简单地表达在一阶数论中。然后他使用原始递归函数去编码公式，甚至是公式的序列。最后他用原始递归函数去计算，被重新表达公式的性质，这包括，一个公式是合式公式，一个公式的序列是一个证明，以及一个公式是一个定理。

要用一长串的引理才能展示得了原始递归函数有多么强大。以下是一些个例子，其显示了加法乘法，及指数运算都是原始递归的。

定义加法运算函数$P(x,y)$，为如下：

$P(0,y)=η(y)$

$P(n+1,y)=σ(P(n,y))$

(注意，这满足原始递归的定义，因为函$数g(x_1,x_2,x_3)=η(σ(x_1))$ 是可由初始函数$η$以及$σ$，通过合成来定义的。)

然后定义乘法函数$T(x,y)$，为如下：

$T(0,y)=ζ( )$

$T(n+1,y)=P(T(n,y),y)$.

接下来我们定义指数函数$E(x,y)$，(通常$0^0$被认为作未经定义的，但是因为原始递归函数必须是全函数，所以我们定义$E(0,0)$为$1$)因为原始递归函数只允许我们在第一个变元那里递归，所以我们需要两步来定义指数函数：

$R(0,y)=σ(ζ( ))$

$R(n+1,y)=T(R(n,y),y)$

最后我们可以通过合成，定义$E(x,y)=R(η(y),η(x))$ (回想起$η$是恒等函数，所以这里可以更简单地写作$E(x,y)=R(y,x)$)

指数函数E的增长得非常陡峭，比如$E(10,10)$就是一百亿，而$E(50,50)$则已经超过$10^{84}$(因此，显著地超过了我们对宇宙中原子数量的估计值)。然而还有增长得快得多得原始递归函数。如我们看到的那样，$E$是通过慢增长函数$σ$来定义出来的，其使用了三个原始递归的应用：一个于加，一个于乘，然后就是指数运算。我们可以继续运用原始递归去构造一系列增长得难以想象地快的函数。让我们在定义超指数函数的系列中再多做一步，$H(n,m)$ 为$2$次方的$2$次方的$2$次方…的$m$次方，像一座塔一样的$n$个$2$。$H$是原始递归的，因为它可以通过从E再多用一次原始递归，而定义出来：

$H(0,y)=y$

$H(n+1,y)=E(2,H(n,y))$

因此$H(2,2)=2^4=16，H(3,3)=2^256$，多于$10^{77}$，与宇宙中原子的数目相当。如果你嫌这还不够大，你可以考虑$H(4,4)$。如果要用$10$进制来写这个数的话，前面的$1$后需接的$0$的数量，会比我们宇宙中粒子的数量都还多

<br/>

3.1 	Recursive Functions

原始递归函数的集是一个关于可计算函数的很庞大的类。实际上，它们可以被表征为在时间上可计算函数的集，这些函数是一些n的原始递归函数，而这里的n是输入的长度。例如，因为$H(n,n)$是一个原始递归函数，那么原始递归函数包含所有时间[$H(n,n)$](见下一节关于包含时间的计算复杂性(computational complexity)的讨论)。因此，原始递归函数包含所有这样的函数，其都是适宜于被任何，可以想象到的适合量度所计算的，甚至远远超过以上这些。

然而，原始递归函数并不包含所有原则上的可计算函数。为了看清这点，我们可以再次使用对角线法。我们可以系统地编码，所有元数为$1$的原始递归函数的定义，然后称这些为$p_1,p_2,p_3$等等。

然后我们可以构造一个图灵机去计算下面这些对角线式函数，$D(n)=p_n (n)+1$

注意，$D$是全的，可计算的，从$N$到$N$的函数，但它不是原始递归的，为什么呢？为了构造矛盾，假设，$D$是原始递归的，那么，对于某个$d∈N$，$D$将等同于$p_d$。但是这样一来就会出现，

$p_d (d)=p_d (d)+1$

而这是一个矛盾。因此，$D$不是原始递归的。

唉，上面的对角线论证，可以被考虑为对，所有为可计算函数的类的候选项的，全函数，都适用。对此问题来说，如果我们想要所有原则上可计算函数，而不只是实践上的，那么我们便需要引入一种无界的搜索操作(unbounded search operation)。这就是哥德尔将原始递归函数扩展到递归函数的做法。

For $i=0$ to $∞$ do $\{$

if $f(i,x_1,…,x_k)=1$, then output $i$
$\}$


所以，如果$f(i,x_1,…,x_k)=1$，并且对于所有$j<i，f(j,x_1,…,x_k)$是已定义的，但不等于$1$，那么，$μ[f](x_1,…,x_k )=i$，否则$μ[f](x_1,…,x_k )$就是未定义的。

哥德尔定义递归函数集为，在合成，原始递归，以及$μ$下的初始的原始递归函数，的闭包。有了这个定义，递归函数将非常精准地与，在lambda演算，克莱尼形式系统，马尔可夫算法，波斯特机与图灵机中的，部分可计算函数(partial computable function)的集相同。

<br/>

4. Computational Complexity: Functions Computable in Practice

在二战中，图灵帮助设计并建造了一台专门的计算设备，被称为图灵炸弹(Bombe at Bletchley Park)。他运用这个东西去破解了德国的英格玛密码(“Enigma” code)，为盟军事业提供了极大的帮助(Hodges, 1992)。到了1960年代，计算机被广泛运用于了工业界与大学中。随着算法的发展，无数难题都得到了解决，一些数学家与科学家开始根据它们的效率，为这些算法分类，并寻找对特定问题的最优算法。而这是现代计算理论(theory of computation)的开端。
在这一节中我们开始处理复杂性，而不再是可计算性，而所有我们考虑的图灵机在这些输入上都将能够停机。我们将假定图灵机通过输出$“1”$表示接受，而非停机，那$“0”$则为拒绝，因此，我们从新定义被一个全图灵机接受的集合$M$，

$L(M)={n∣M(n)=1}$.

一个算法所需要的时间，取决于输入与运行该算法的机器。在复杂性理论中第一个关键的见解就是，对一个算法复杂性的，较好的衡量方法是，运用渐进于最坏情况复杂度(worst-case complexity)，其根据于输入大小$n$ 。

对于一个输入$w$，设$n=|w|$ 为$w$的长度。根据(Hartmanis, 1989)，我们说一个图灵机$M$的，运行所需时间为(runs in time) $T(n)$，如果，对于所有$n$长的$w$，$M(w)$ 最多需要 $T(n)$步然后停机。这就被称为最坏情况复杂度，因为 $T(n)$必须不小于，在长度为$n$的任何输入上所需的时间。

对于任何一个函数，$T:N→N$，使得
$TIME[T(n)]=\{A∣A=L(M) for \ some \ M  \ that \ runs \ in \ time \ T(n)\}$.

Alan Cobham与Jack Edmonds确定了复杂度的P类，其为在一定多项式时间量(polynomial amount of time)中可识别的问题。这已是一个很好的数学工具，涵盖了可行问题的类，即所有这些问题的中等大小的实例都可以被识别出来，

$P=\underset{i=1,2,…}{\bigcup} TIME[n^i]$

任何不在$P$中的问题，都是一定不可行的。而另一方面，有算法在$P$中的那些自然的问题，都倾向于，最终会有一个，被发现对这些问题实际可行的算法。

许多重要的包括在$P$中的计算复杂性类，都已被定义与研究，而少数则是$NP$，$PSPACE$，及$EXPTIME$。$PSPACE$包括那些，用多项式存储空间量(polynomial amount of memory space)可解的问题。$EXPTIME$是关于，在时间$2^(p(n))$上可解的一些多项式$p$的集。

或许上面最有意思的类是$NP$：非确定性多项式时间(nondeterministic polynomial time)。其定义不是来自于一台真实的机器，而是一个数学抽象。一个非确定性图灵机$N$，其在每一步的两个可能行动中做出(猜测)一个选择，如果在输入$w$上，这些选择的某个序列是可接受的，那么我们说$N$接受$w$，以及我们说，$N$在输入$w$上花了非确定的时间就是在这个导向接受的序列中所花的步数。非确定性机器不计所有其他的可能选择，而只计正确选择的单个序列。

$NP$时常被描绘为问题集$S$，其带有元素关系(membership)的简短证明。比如，假设我们被给定了关于$m$大小的自然数，$a_1,…,a_m$及一个目标数t$$，的一个列表。这是一个子集和问题(Subset Sum problem)的实例：是否存在一个元素为m个数的子集，其和正好是t？在非确定性线性时间中，这个问题非常容易解决：对于每一个$i$，我们猜其是否取$a_i$。然后我们加上所有我们决定去取的数，如果上面的和等于$t$那么就接受。因此，这个非确定性时间是线性的，即，某个常值乘以输入的长度n。然而在此没有一种已知的(确定性)方法，可以在小于$n$的指数级时间内，去解决这个问题。

现在已经有了大量关于算法的研究，并且一些重要问题的复杂度也得到了很好的理解。尤其是，对问题间的还原进行了定义，并用其去比较两个问题的相对难度。直观地，我们说A是可还原(reducible)到B上的$(A≤B)$ ，如果有一个简单的翻译τ，以一种保持元素关系的方式，将A的实例映射为$B$的实例，即，$τ(w) ∈B⇔ w ∈A$。

值得注意的是，多数自然发生的计算问题，都被证明为，对上述的其中一个类中完全的(一个问题$A$，对一个复杂性类$C$是完全的，当，$A$是$C$中的一个成员，而C中的所有其他元素$B$不难于$A$，即，$B≤A$。两个对于同一个类而完全的问题拥有相等的复杂度。)

关于这种完全性现象的原因并没有得到充分的解释。一个可信的解释是，自然计算问题(natural computational problems)往往是通用的(译注：或作普遍的，下同)，在图灵的通用机的意义上。而关于某个既定复杂性类的，一个通用问题，可以模拟该类中任何其他问题。而NP类被如此广泛研究的原因则是，大量且重要的实际问题都是对于$NP$完全的，包括子集和问题。而其中没一个被已知，存在一个算法，其可以快于指数级的时间去解决它们，尽管一些NP完全问题允许关于它们的近似可行解。

关于计算复杂性的大量的问题都还是开放的。我们知道，严格地说，更多的计算资源(computational resources)，可使得我们解决，严格上更难的问题，例如$TIME[n]$真包含于$TIME[n^1.01 ]$中，相似地，对于SPACE ，以及其他量度来说同样如此。然而，在不同计算资源间的权衡上，我们的理解仍然十分贫乏。显然，$P$被包含于$NP$中。进一步，$NP$被包含在$PSPACE$中，因为在$PSPACE$中，我们可以系统性地尝试$NP$计算的每一个分支，对连续的分支再利用空间，并且接受它，当且仅当这些分支中的任何一个导向了接受。$PSPACE$被包含在$EXPTIME$中，因为，当一个PSPACE机要花超过指数级的时间时，那么它就确切地重复了一些配置，所以它也一定是在无限循环。以下是关于上面这些类的已知关系

$P⊆NP⊆PSPACE⊆EXPTIME$

然而，尽管看上去很清楚地，P真包含于NP，而NP真包含于PSPACE，PSPACE也真包含于EXPTIME，但其中任何这些类的不等关系都没有得到过证明。实际上，甚至对于P是否不同于PSPACE，或者NP是否不同于EXPTIME，我们都是不知道的。从上面可知，真包含关系只有，P真包含于EXPTIME。余下的问题，涉及到不同计算资源的相对效力，而这是个计算理论中的基础性的未解难题。

关于计算复杂性有一个广泛的理论，本条目只简单描述了这一领域，将其置于在了，什么是原则上与实践上可计算的，这个问题的语境下。对于那些有志于学习更多关于复杂性的读者有很多非常不错的著作，比如[Papadimitriou, 1994]，与[Arora and Barak, 2009]，以及同样有条目Computational Complexity Theory。

<br/>

4.1 	Significance of Complexity

下面那张图画出了我们已经讨论过的所有复杂性类和一些其他类。这张图来自于描述复杂性的工作(Immerman, 1999)，这表明了所有重要的复杂性类都有其描述性特征。Fagin通过提供了NP = SO∃的证明而开启了这个领域。即，一个性质属于$NP$，当且仅当，它在存在性二阶逻辑(existential second-order logic)中是可表达的(Fagin, 1974)。

Vardi与本词条的作者之后独立证明了 $P = FO(LFP)$：一个性质属于$P$，当且仅当，其在一阶逻辑加上一个最小不动点运算符(least fixed-point operator, LFP)后，是可表达的，这个最小不动点运算符形式化了通过归纳去定义新关系的能力。其中一个有趣的推论是 $P = NP \ iff \ SO = FO(LFP)$。这意味着，$P$是等于$NP$的，当且仅当，所有在二阶逻辑中是可表达的性质，在一阶逻辑中加上归纳定义时也是可表达的(有关，语言是否超过了，有限的有序输入结构，这个问题的更多细节，见(Immerman, 1999))。

![The World of Computability and Complexity](https://plato.stanford.edu/entries/computability/descriptiveWorld2015.jpg "The World of Computability and Complexity")

图中顶端的右边是递归可枚举问题，其包括了递归可枚举完全问题，例如停机问题。而在左边是共递归可枚举问题的集，包括共递归可枚举完全问题$\overline{Halt}$，即，永远不会在给定输出上停机的图灵机集。在2.3节的最后，我们提到了递归可枚举问题集，与共递归可枚举问题集的交集，是等于递归问题集的。原始递归问题集是递归问题的一个真子集。

让我们将目光移向这张图的底部，其有一个区域被用绿色虚线标记出了“真正可行(truly feasible)”。注意，这不是一个数学上严格定义的类，而是一个直观的概念，对于所有那些合理大小的实例，在合理的时间量内，使用我们能承担得起的计算机，而能被准确解决的问题(有趣的是，这些年来随着计算机运算速度的急剧增长，我们对于我们能够处理多大实例，的相关期望，也相应地提高了。因此，什么是真正可行的边界的变化，比计算机运算速度的增加，显示得要慢)

就像前面所说的那样，$P$是一个很好的数学工具，涵盖了可行问题的集。在$P$中的有些问题，其问题大小$n$要求$n^{1000}$时间，因此是不可行的。“自然”在这里似乎成了我们的朋友，也就是说在 $P$中自然发生的那些问题倾向于相对简单的算法，及“自然”问题也往往是可行的。对于大小为n的问题所要求的步数，往往小于，有着较小乘法常量$c$与很小指数$k$的$cn^k$，即$k≤2$。

实践中，关于自然发生问题的渐进复杂度(asymptotic complexity)，往往是决定它们是否可行的关键议题。对于有着复杂度$17n$的问题，在现代计算机中一分钟内就可解决，其每个实例大小为十亿。而另一方面，一个最坏情况复杂度为$2^n$问题，即使其实例大小只有100也用尽我们一生的时光都无法被解决。

值得注意的是，自然问题往往是对于一些重要的复杂性类完全的，即图中那些类，而只有极少数是其他的。这个有趣的现象意味着，算法与复杂度将不仅仅是抽象概念，它们在实践层面也非常重要。我们在提供，关于我们感兴趣的问题对于一个著名的复杂性类是完全的，这个方面的证明上，已取得了瞩目的成功。如果该类被$P$所包含，那么我们通常可以查找一个已知能行的算法，否则，我们必须研究问题的简化与近似，这可能可行。

关于$NP$优化问题(NP optimization problems)的近似有着丰富的理论(见，(Arora & Barak, 2009))。例如，上文提到的子集和问题，是一个$NP$完全问题。更可能的是，它需要指数级时间去判定一个给定子集和问题是否有一个精确解。然而，如果我们仅仅想看看我们是否能达到给定位数的精度，那么这个问题就将变得非常简单，即，子集和问题很难，但去近似则很简单。

甚至，对递归可枚举完全的停机问题也有很多重要而可行的子问题。给定一个程序，它总的来说不可能知道它自己在干什么以及其最终是否停机。然而，多数被程序员与学生写下的程序都可被现代的编译器与模型检查器，自动地分析，优化，甚至修正。

$NP$类在实践与哲学上都非常重要。它是这样的问题类$S$，其中，任意输入$w$，在$S$中，当且仅当，存在证明$P(w)$，使得，$w∈S$，且$P(w)$不比 $w$大出许多。所以，不那么正式地来说，我们可以认为NP有一个可被达到的脑力活动的集，当，我们能够判断$w∈S$，且可以说服其他人我们做到了时。

布尔可满足性问题(Boolean satisfiability problem)，SAT，是第一个被证明的NP完全问题(Cook, 1971)，即，它是一个最难的$NP$问题。事实是，SAT是$NP$完全的，意味着，在NP中的所有问题都可被还原为SAT。多年来，研究者已经搭建了非常高效的SAT求解器，其可以快速地解决许多SAT的实例，即，找到一个可满足的指派，或者是证明没有这样的一个指派，甚至对于有着百万变量的实例来说。因此，SAT求解器被常用作通用问题求解器(general purpose problem solvers)。另一方面，对于一些已知的小实例类，当前的SAT求解器的是失败的。因此，$P$与$NP$问题的一部分涉及到，SAT的实际与理论复杂度(Nordström, 2015)。
