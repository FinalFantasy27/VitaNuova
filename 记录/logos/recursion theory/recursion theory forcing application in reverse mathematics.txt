test_alpha0 2022/1/28 15:06:07
递归论力迫法的用处是，产生一些图灵度满足所需要求的集合

test_alpha0 2022/1/28 15:06:21
然后这些集合可以用于构造一些反推数学中的模型

test_alpha0 2022/1/28 15:06:55
众所周知，要想证明公理系统A推不出命题B，一个标准的证法就是构造一个A的模型，在其中B不成立

test_alpha0 2022/1/28 15:07:18
RCA0是反推数学中的一个很基础的公理系统

test_alpha0 2022/1/28 15:07:49
它是一个二阶算术公理系统，换句话说，讨论自然数集和它的子集族

test_alpha0 2022/1/28 15:08:32
一个二阶算术模型，称为ω-模型，如果它的一阶部分是标准的，或者说它的自然数就是标准自然数。当然这里二阶部分没必要标准。

test_alpha0 2022/1/28 15:08:58
换句话说，它的P(ω)没必要是P(ω)，可以是其他的。

test_alpha0 2022/1/28 15:09:37
关于RCA0的一个基本结论是，RCA0的ω模型(ω,M)一定有下面的性质：

test_alpha0 2022/1/28 15:10:17
M是P(ω)的子集。对任意a∈M，若a能计算出b，则b∈M。
对任意a,b∈M，有a⊕b∈M

test_alpha0 2022/1/28 15:11:05
这里a⊕b是能算出a,b的最小图灵度，一般取成{x|x=2y,y∈a或x=2y+1,y∈b}

test_alpha0 2022/1/28 15:12:32
ACA0的ω-模型多了一条要求：
对任意a∈M，有a'∈M

test_alpha0 2022/1/28 15:12:49
我上次讲过a'是什么

安 2022/1/28 15:12:58
test_alpha0  
一个二阶算术模型，称为ω-模型，如果它的一阶部分是标准的，或者说它的自然数就是标准自然数。当然这里二阶部分没必要标准。
@test_alpha0 这里它的二阶部分不一定真的是一阶部分的所有子集，是因为二阶算术其实是个two sorted的一阶理论是吗

test_alpha0 2022/1/28 15:12:59
不过@安 你知道图灵跳跃吗？

test_alpha0 2022/1/28 15:13:06
安  
@test_alpha0 这里它的二阶部分不一定真的是一阶部分的所有子集，是因为二阶算术其实是个two sorted的一阶理论是吗
@安 对

test_alpha0 2022/1/28 15:13:59
在讲图灵跳跃的同时，也会讲递归论力迫法里非常非常常用的一个方法——相对化。

test_alpha0 2022/1/28 15:14:40
设a,b是两个自然数集。对于"a能算出b"，或者说"b是a-可计算的"这个概念，你是否了解？

test_alpha0 2022/1/28 15:17:09
可计算这个概念有很多基本性质。比如，存在一列可数的程序Φ_e，b是a-可计算的当且仅当x↣Φ_e(a,x)是b的特征函数。

test_alpha0 2022/1/28 15:18:06
我们可以略微改造“可计算”这个概念。
取定自然数集x。
我们称a能算出b，如果在旧的意义下，a⊕x能算出b。

test_alpha0 2022/1/28 15:18:38
换句话说，我们可以使用x辅助计算。
这个改造了的可计算概念，与原版的可计算概念，非常非常相似。

test_alpha0 2022/1/28 15:19:15
这就导致了，对于很多递归论里的定理，如果把可计算改成x-可计算，定理仍然成立。由此可以得到一大批新定理。

test_alpha0 2022/1/28 15:19:30
下面我定义0'。它是一个不可计算的集合。

test_alpha0 2022/1/28 15:19:57
0'={e|Φ_e(e)停机}

test_alpha0 2022/1/28 15:20:08
上次我用的是Φ_e(0)，这是图灵等价的。

test_alpha0 2022/1/28 15:21:52
我们证明0'是不可计算的。假设0'可计算，我们定义一个可计算函数f，
f(x)=
Φ_e(e)+1，若Φ_e(e)停机
0，otherwise

test_alpha0 2022/1/28 15:22:43
设f(x)=Φ_u(x)，那么Φ_u(u)=f(u)=Φ_u(u)+1，矛盾。

test_alpha0 2022/1/28 15:22:53
现在，我们把可计算概念相对化

test_alpha0 2022/1/28 15:23:18
那么0'就变成了x'={e|Φ_e(x,e)停机}

test_alpha0 2022/1/28 15:23:42
我们的证明也就变成了，x'不是x-可计算的。

雪月桜花の国 2022/1/28 15:24:46
相对化在早期表述下的严格处理是什么时候写的

雪月桜花の国 2022/1/28 15:24:56
看kleene的文章都是一笔带过

test_alpha0 2022/1/28 15:25:34
定义[ω]^2={(a,b)|a,b∈ω, a<b}

test_alpha0 2022/1/28 15:26:21
RT22是说，对任意[ω]^2的二染色，存在无限自然数集A，使得A的任意两个点之间的连线都同色。

test_alpha0 2022/1/28 15:26:41
就是拉姆赛定理，你们之前听说过吗？

安 2022/1/28 15:27:42


test_alpha0 2022/1/28 15:27:55
可以构造一个图，顶点是全体自然数，认为两点之间都有一条边。RT22就是说，对这个图的边的任意二染色，存在一个无限顶点集，它的任意两条边都同色。

test_alpha0 2022/1/28 15:28:26
(大概就是小学奥数里任意6个人之间都有3个人相互认识或者相互不认识的加强版)

test_alpha0 2022/1/28 15:29:55
拉姆塞定理是“给定一个集合(在这里是染色)，存在一个集合”的Π¹₂型命题

test_alpha0 2022/1/28 15:30:53
有些这种命题具有“躲角性”，换句话说，对任意A,X，如果给定的集合A算不出X，那么存在一个产生出来的集合B也算不出X

test_alpha0 2022/1/28 15:31:37
我们的目标是，先证明RT22的躲角性，再利用躲角性构造RCA0+RT22+¬ACA0的ω-模型

安 2022/1/28 15:32:23
test_alpha0  
拉姆塞定理是“给定一个集合(在这里是染色)，存在一个集合”的Π¹₂型命题
@test_alpha0 算术层谱里是只要涉及“二阶”量化上标就是1吗？例如，任给一个集合，存在一个个体，这里在算术层谱里上标也是1吗？

test_alpha0 2022/1/28 15:32:30
它为什么被称为躲角性呢？
因为一般人们把图灵度大于等于X的集合称为图灵角，而算不出X的集合则在这个角之外。

test_alpha0 2022/1/28 15:32:50
安  
@test_alpha0 算术层谱里是只要涉及“二阶”量化上标就是1吗？例如，任给一个集合，存在一个个体，这里在算术层谱里上标也是1吗？
@安 嗯，是的，而且下标也是1

test_alpha0 2022/1/28 15:33:31
[你群最垃圾]大龄失学儿童  
英文是啥，cone吗
@雪月桜花の国 cone avoiding

test_alpha0 2022/1/28 15:33:58
[你群最垃圾]大龄失学儿童  
我看他们都翻译成图灵锥
@雪月桜花の国 那是我的错，那就叫躲锥性吧

test_alpha0 2022/1/28 15:34:21
接下来我们叙述RT22的躲锥性命题

test_alpha0 2022/1/28 15:34:47
设X是集合，c是二染色。若c算不出X，则存在单色子图A，使得A也算不出X。

test_alpha0 2022/1/28 15:35:08
接下来，我会讲一下我们证明这个命题的流程。

test_alpha0 2022/1/28 15:35:24
首先我们回顾一下RT22的原始证明。

test_alpha0 2022/1/28 15:36:04
我们构造一个辅助集合A。在构造过程中，我们需要辅助集合B。

test_alpha0 2022/1/28 15:36:14
一开始，A是空集，B=ω

test_alpha0 2022/1/28 15:37:02
然后，我们把0放进A里。然后0与右边的数的连线可能是红的或者蓝的，其中至少有一个无限集。我们把B变成那个无限集。

test_alpha0 2022/1/28 15:37:42
然后把B的最小元n放进A里，然后n与B中的数的连线可能是红的或蓝的，我们取一个无限集，把B改成那个无限集

test_alpha0 2022/1/28 15:38:15
不断这样做下去，最终我们得到无限集A，对任意元素a<b，(a,b)的染色只取决于a。

安 2022/1/28 15:38:54
这里用的是konig引理，无穷二叉树会有无穷枝

test_alpha0 2022/1/28 15:39:16
因此，我们可以对A染色。若(a,b)是红的，就把a染成红的。然后那个单色无限集就是我们所需要的。

test_alpha0 2022/1/28 15:40:07
接下来，在RT22的躲锥性证明中，我们将会进行这样的流程

test_alpha0 2022/1/28 15:40:47
第一步，取一个子集A，使得A仍然算不出X，且c在A上的染色是稳定的

test_alpha0 2022/1/28 15:41:17
这里，稳定的意思是，对任意a，(a,b)的颜色在b充分大时是常数

test_alpha0 2022/1/28 15:42:01
我们就可以把这个颜色染给a。注意我们没法保证这个染色不能算出X。

test_alpha0 2022/1/28 15:42:26
通过这一步，我们可以不妨设一开始的染色c就是稳定的

test_alpha0 2022/1/28 15:42:47
test_alpha0  
第一步，取一个子集A，使得A仍然算不出X，且c在A上的染色是稳定的
补，使得c⊕A仍然算不出X。

test_alpha0 2022/1/28 15:44:04
现在我们有了自然数集上的二染色。我们接下来证明一个结论：对任意自然数集的二染色和一个不可计算集X，存在一个单色无限自然数集算不出X。

test_alpha0 2022/1/28 15:45:04
它的相对化是，X是(那个稳定染色)-不可计算的，然后那个单色无限自然数集⊕(稳定染色)也算不出X

test_alpha0 2022/1/28 15:47:12
现在，设c是一个稳定染色，我们通过上述引理得到一个无限集A，我们可以通过A和c算出一个单色无限集：
对任意a,b,c,d∈A，当x∈A充分大时，(a,x),(b,x),...的颜色都是A所对应的颜色。因此我们可以通过从小到大搜索A找到对应的x。任取第一个元素，然后不断这样找，最后就得到了一个c⊕A可计算的单色无限集。

test_alpha0 2022/1/28 15:47:38
这几步大概需要一小段时间理解

test_alpha0 2022/1/28 15:47:49
你们理解了就给我说一下，有什么问题也说一下

雪月桜花の国 2022/1/28 15:50:09
test_alpha0  
现在，设c是一个稳定染色，我们通过上述引理得到一个无限集A，我们可以通过A和c算出一个单色无限集：
对任意a,b,c,d∈A，当x∈A充分大时，(a,x),(b,x),...的颜色都是A所对应的颜色。因此我们可以通过从小到大搜索A找到对应的x。任取第一个元素，然后不断这样找，最后就得到了一个c⊕A可计算的单色无限集。
怎么知道取到了正确的x，这过程不会停机吧

test_alpha0 2022/1/28 15:50:51
[你群最垃圾]大龄失学儿童  
怎么知道取到了正确的x，这过程不会停机吧
@雪月桜花の国 用c检查所有(a,x),(b,x),...的颜色，只需要检查有限个。
如果x不符合，就在A里找下一个

test_alpha0 2022/1/28 15:51:51
现在A的每个元素都是“最终红色”的，我们要找一个红子集
找了n个元素。两两连红之后，我们可以再找下一个元素和它们都连红。

雪月桜花の国 2022/1/28 15:52:05
test_alpha0  
@雪月桜花の国 用c检查所有(a,x),(b,x),...的颜色，只需要检查有限个。
如果x不符合，就在A里找下一个
只找abcd四个？

test_alpha0 2022/1/28 15:52:21
[你群最垃圾]大龄失学儿童  
只找abcd四个？
@雪月桜花の国 看我上面的说明。

雪月桜花の国 2022/1/28 15:52:56
要找的子集也是无限的吧

test_alpha0 2022/1/28 15:53:08
[你群最垃圾]大龄失学儿童  
要找的子集也是无限的吧
@雪月桜花の国 对，但可以一步一步找出来

雪月桜花の国 2022/1/28 15:53:21
所以是re的？

test_alpha0 2022/1/28 15:53:22
先找第一个，再找第二个，以此类推

test_alpha0 2022/1/28 15:53:29
[你群最垃圾]大龄失学儿童  
所以是re的？
@雪月桜花の国 是可计算的呀

test_alpha0 2022/1/28 15:53:58
[你群最垃圾]大龄失学儿童  
所以是re的？
@雪月桜花の国 要是你先找了第3个，之后不知道什么时候才能找到第2个，那才会是re

雪月桜花の国 2022/1/28 15:54:17
任给一个a怎么判定它是最终蓝的还是只是没到足够大的x翻红

test_alpha0 2022/1/28 15:54:41
[你群最垃圾]大龄失学儿童  
任给一个a怎么判定它是最终蓝的还是只是没到足够大的x翻红
@雪月桜花の国 A是通过那个引理取出来的最终蓝的集合。

雪月桜花の国 2022/1/28 15:55:14
一开始就稳定吗

test_alpha0 2022/1/28 15:55:16
“最终染色”不一定能躲锥，但引理也不要求它躲锥，而是说有一个躲锥的子集

test_alpha0 2022/1/28 15:55:41
[你群最垃圾]大龄失学儿童  
一开始就稳定吗
@雪月桜花の国 一开始未必稳定，但我们可以找一个稳定的躲锥子集，所以可以不妨设是稳定的

test_alpha0 2022/1/28 15:55:41
[你群最垃圾]大龄失学儿童  
一开始就稳定吗
@雪月桜花の国 一开始未必稳定，但我们可以找一个稳定的躲锥子集，所以可以不妨设是稳定的

安 2022/1/28 15:57:27
接下来要证明这个单色无限集算不出X？

test_alpha0 2022/1/28 15:57:57
安  
接下来要证明这个单色无限集算不出X？
@安 这个单色无限集是A⊕c可计算的，但A⊕c算不出X，所以它也算不出X。

安 2022/1/28 15:58:16
行

test_alpha0 2022/1/28 15:59:26
接下来，我们证明我们的第一个引理

test_alpha0 2022/1/28 16:00:03
设X不可计算，c是一个可计算的染色，则存在一个集合A，使得A算不出X，且c在A上是稳定的

test_alpha0 2022/1/28 16:00:17
它的相对化就是我们的第一步

test_alpha0 2022/1/28 16:00:33
它的证明需要力迫法。递归论力迫法说起来其实相当简单。

test_alpha0 2022/1/28 16:01:05
基本思路就是，我们要构造一个东西，我们一方面不断给它添砖加瓦，一方面不断缩小它的候选。

test_alpha0 2022/1/28 16:01:30
接下来，我们定义mathias condition

test_alpha0 2022/1/28 16:01:54
它是一个集合对(A,B)，A是有限集，B是无限集，而且max A<min B

test_alpha0 2022/1/28 16:02:14
直观来说，A是已经选好的元素，B是我们的水库

test_alpha0 2022/1/28 16:04:06
设φ是一个公式，如果对B的任意无限子集X，有φ(A∪X)成立，我们就说(A,B)⊩φ

test_alpha0 2022/1/28 16:04:42
在引理的具体证明里，我们还要求B必须是可计算的集合

test_alpha0 2022/1/28 16:06:17
我们考虑φ_n(S)：对S中充分大的元素s，(n,s)同色。

test_alpha0 2022/1/28 16:07:36
啊，忘了说，关于condition的大小比较。
称(A,B)>(A',B')，若(A',B')是这样得到的：把B中的有限个元素丢进A里，然后删除B中任意多个元素。

test_alpha0 2022/1/28 16:09:29
现在，设(A,B)是一个condition，我们可以加强这个条件使其满足φ_n。因为B是无限集，{m>n|(n,m)染红}与{m>n|(n,m)染蓝}中至少有一个与B的交是无限集，把B改成那个交即可。

test_alpha0 2022/1/28 16:11:32
接下来还有一个任务：我们需要保证我们最终得到的集合不能算出X

雪月桜花の国 2022/1/28 16:12:46
test_alpha0  
现在，设(A,B)是一个condition，我们可以加强这个条件使其满足φ_n。因为B是无限集，{m>n|(n,m)染红}与{m>n|(n,m)染蓝}中至少有一个与B的交是无限集，把B改成那个交即可。
phi_n(S)里的参数S是谁

test_alpha0 2022/1/28 16:13:26
[你群最垃圾]大龄失学儿童  
phi_n(S)里的参数S是谁
@雪月桜花の国 (A,B)⊩φ，其中S是φ的一个自由变元

test_alpha0 2022/1/28 16:13:41
[你群最垃圾]大龄失学儿童  
phi_n(S)里的参数S是谁
@雪月桜花の国 不需要指出S是谁

雪月桜花の国 2022/1/28 16:14:25
对于任意的A并（B的子集）都满足？

test_alpha0 2022/1/28 16:14:34
[你群最垃圾]大龄失学儿童  
对于任意的A并（B的子集）都满足？
@雪月桜花の国 对

雪月桜花の国 2022/1/28 16:14:43
那得首先要求A和n同色

test_alpha0 2022/1/28 16:15:15
[你群最垃圾]大龄失学儿童  
那得首先要求A和n同色
@雪月桜花の国 我们现在要做的是，从一个普通染色里得出一个稳定染色

test_alpha0 2022/1/28 16:15:26
test_alpha0  
设X不可计算，c是一个可计算的染色，则存在一个集合A，使得A算不出X，且c在A上是稳定的
.

test_alpha0 2022/1/28 16:15:53
test_alpha0  
接下来还有一个任务：我们需要保证我们最终得到的集合不能算出X
接下来要做的是这个

test_alpha0 2022/1/28 16:16:40
换句话说，对任意图灵泛函Φ_e，我们需要Φ_e(G)≠X，对任意G∈[(A,B)]

test_alpha0 2022/1/28 16:17:09
这里[(A,B)]就是{A∪B'|B'是B的无限子集}

test_alpha0 2022/1/28 16:17:30
test_alpha0  
换句话说，对任意图灵泛函Φ_e，我们需要Φ_e(G)≠X，对任意G∈[(A,B)]
我们把这个任务称为φ'_e

test_alpha0 2022/1/28 16:18:23
要做到(A,B)⊩φ'_e，只需找到一个n，使得保证Φ_e(G,n)≠X(n)

test_alpha0 2022/1/28 16:18:52
现在给定(A,B)，我们尝试增强它，使得它forces Φ_e

test_alpha0 2022/1/28 16:19:30
首先我们尝试把B的一个子集K放进A里，使得Φ_e(A∪K,n)=1-X(n)

安 2022/1/28 16:19:33
test_alpha0  
我们考虑φ_n(S)：对S中充分大的元素s，(n,s)同色。
@test_alpha0 这里(A, B)||-phi，用AUB’带入S。那似乎A什么颜色不重要，因为只要让那个“充分大”大过A中所有元素就可以了？

test_alpha0 2022/1/28 16:20:21
安  
@test_alpha0 这里(A, B)||-phi，用AUB’带入S。那似乎A什么颜色不重要，因为只要让那个“充分大”大过A中所有元素就可以了？
@安 如果我们把所有的φ_n都满足了，那么最后的A肯定是稳定染色

test_alpha0 2022/1/28 16:20:41
因为它不但对A里的元素稳定，它对A外的元素也稳定

test_alpha0 2022/1/28 16:20:48
test_alpha0  
首先我们尝试把B的一个子集K放进A里，使得Φ_e(A∪K,n)=1-X(n)
现在回到这里

test_alpha0 2022/1/28 16:21:33
这里我说的Φ_e(A∪K,n)，指的是Φ_e调用参数时，最多只调用到K的最大元，如果还调用更大的那就算不停机

test_alpha0 2022/1/28 16:22:19
如果我们确实可以找到这样的K，那就把这个K丢进A里，就能保证条件⊩φ'_e了

test_alpha0 2022/1/28 16:23:12
如果我们找不到这样的K，那么我们反过来尝试，对每个n，找一个K，使得Φ_e(A∪K,n)=X(n)，且这个计算在|K|步之内就能做完。

test_alpha0 2022/1/28 16:23:31
如果每个n都能找到K，那么X可计算！
这是矛盾的。

test_alpha0 2022/1/28 16:24:29
如果有一个n找不到K，那么对任意G∈[(A,B)]，Φ_e(G,n)根本就不停机，因为它既没法等于X(n)，也没法等于1-X(n)。

test_alpha0 2022/1/28 16:24:51
因此，我们无需做任何增强，直接就有(A,B)⊩φ'_e

test_alpha0 2022/1/28 16:25:41
最后别忘了最基本的任务：A是无限集。因此我们需要对任意n，A里至少有n个元素。我们称这个任务是φ''_n。它显然很容易完成。

test_alpha0 2022/1/28 16:26:39
现在，φ_n，φ'_e，φ''_n是三组可数个任务，它们的总数也是可数的。
我们把它们列成一行，然后从(∅,ω)开始，一个一个满足。

test_alpha0 2022/1/28 16:27:31
在这个过程中，A一步一步增大，最后得到的A，是无限集，不能通过任何Φ_e算出X，且对任意n，(n,a),a∈A在a充分大时同色。

test_alpha0 2022/1/28 16:27:36
这个A就是我们所需要的。

test_alpha0 2022/1/28 16:27:50
引理证毕

雪月桜花の国 2022/1/28 16:30:21
test_alpha0  
如果我们找不到这样的K，那么我们反过来尝试，对每个n，找一个K，使得Φ_e(A∪K,n)=X(n)，且这个计算在|K|步之内就能做完。
这种情况下要怎么满足条件

雪月桜花の国 2022/1/28 16:30:52
哦，只要有一个不一样就行

test_alpha0 2022/1/28 16:31:11
[你群最垃圾]大龄失学儿童  
这种情况下要怎么满足条件
@雪月桜花の国 这种情况下什么都不做就能满足条件。

雪月桜花の国 2022/1/28 16:33:04
test_alpha0  
最后别忘了最基本的任务：A是无限集。因此我们需要对任意n，A里至少有n个元素。我们称这个任务是φ''_n。它显然很容易完成。
这个任务一定能做到取东西的时候避开前两个条件吗

test_alpha0 2022/1/28 16:33:11
(ps:这个引理在我看的教材里是一个习题，这个证明是我自己想的。当然，是先学了其他递归论力迫法证明，才能想出来。)

test_alpha0 2022/1/28 16:34:06
[你群最垃圾]大龄失学儿童  
这个任务一定能做到取东西的时候避开前两个条件吗
@雪月桜花の国 不用管呀。只要(A,B)⊩φ，就有对任意(A',B')<(A,B)，(A',B')⊩φ。

test_alpha0 2022/1/28 16:34:24
因为[(A',B')]⊆[(A,B)]

test_alpha0 2022/1/28 16:35:21
[你群最垃圾]大龄失学儿童  
这个任务一定能做到取东西的时候避开前两个条件吗
@雪月桜花の国 这和优先方法不一样，一个要求只要满足了就永远不会被破坏

test_alpha0 2022/1/28 16:37:57
接下来证明我们的下一个引理

test_alpha0 2022/1/28 16:38:47
设X是不可计算集合，A是ω的子集(视为二染色)。则存在一个单色无限子集，仍然算不出X。
注意，这里不要求A算不出X。

test_alpha0 2022/1/28 16:39:28
这个引理的相对化就是我们在之前讲的规划中所需要的。
只要证明了这个引理，通过之前讲的规划，我们就证明了RT22的躲锥性。

test_alpha0 2022/1/28 16:39:57
在证明这个引理之前，我们需要另一个引理：躲锥基引理。

test_alpha0 2022/1/28 16:40:12
它的证明需要另一种力迫，树力迫。

test_alpha0 2022/1/28 16:41:17
躲锥基引理是这样的：设T是一颗二叉树，其节点视为有限长01串。若T的节点集可计算，X是不可计算集合，则存在T的一条无限路径，使得这条路径也算不出X。

test_alpha0 2022/1/28 16:41:51
这里说一下，mathias力迫证明很多时候都需要某个基引理作为辅助引理，而且它们的用法都差不多。

test_alpha0 2022/1/28 16:42:21
还有很多其他同类的定理，它们有的需要低基引理，有的需要hyperimmune基引理，如此等等。

test_alpha0 2022/1/28 16:42:41
这里引理套引理的现象不是偶然的，而是常见的。

test_alpha0 2022/1/28 16:42:54
接下来，我们证明躲锥基引理。

test_alpha0 2022/1/28 16:43:33
test_alpha0  
躲锥基引理是这样的：设T是一颗二叉树，其节点视为有限长01串。若T的节点集可计算，X是不可计算集合，则存在T的一条无限路径，使得这条路径也算不出X。
啊等一下，补充一个条件：T是无限的树

test_alpha0 2022/1/28 16:44:26
konig定理告诉我们T有无限路径。表面上看，T一定有可计算的无限路径，实则不然，可以构造一个可计算的无限树没有可计算的无限路径。

test_alpha0 2022/1/28 16:44:33
但躲锥还是可以的。

test_alpha0 2022/1/28 16:46:20
这里我们需要的力迫条件是可计算树

test_alpha0 2022/1/28 16:47:04
对两棵可计算树A,B，我们称A>B，若B是A的子树

test_alpha0 2022/1/28 16:47:18
定义[A]={A的无限路径}

test_alpha0 2022/1/28 16:47:34
接下来，我们列出我们的任务

test_alpha0 2022/1/28 16:49:17
φ_e: Φ_e(G)≠X
φ'_e: 所有G∩{0,1,2,..,n}都是某个给定的集合(或者说，A有个长度至少为n的树干)

test_alpha0 2022/1/28 16:50:39
φ'_e很容易满足。考虑A的所有高为n的节点，至少有一个节点上方的树是无限的，否则A就是有限的。我们把A修剪为，让那个节点在树干上，剪掉多余的枝杈。这样修剪后得到的树仍然是有限的。

test_alpha0 2022/1/28 16:57:07
对于φ_e，我们尝试让Φ_e(G,n)=1-X(n)
如果对某个n，A中有无穷多个节点K，使得Φ_e(K,n)进行|K|步计算之后得到的不是X(n)，我们就这样修剪A：
对K∈A，把Φ_e(K,n)计算|K|步。如果得到X(n)就抛弃这个节点。如果没有得到X(n)就保留这个节点。
这样得到的树的每个无限分支G，都要么Φ_e(G,n)=1-X(n)，要么Φ_e(G,n)不停机。这样就满足了φ_e

test_alpha0 2022/1/28 16:59:27
如果对所有n，对任何A中充分高的节点K，都有Φ_e(K,n)=X(n)，且该计算可以在K步之内做完，那么对某个高度m，A中所有高度为m的节点都能通过Φ_e算出X(n)，这就导致了X是可计算的，矛盾！

test_alpha0 2022/1/28 16:59:49
因此φ_e也可以满足

test_alpha0 2022/1/28 17:00:47
同时满足所有φ_e，φ'_n，我们得到一棵树干越来越高的树，这个树干最后会构成一个无限长01串，它是A的一条无限路径，且无法通过任何Φ_e算出X。

test_alpha0 2022/1/28 17:00:51
引理证毕

test_alpha0 2022/1/28 17:01:02
今天就讲到这里吧。有什么不会的可以问我。

test_alpha0 2022/1/28 17:01:49
下次继续讲任意自然数二染色的躲锥性，以及如何通过RT22的躲锥性构造RCA0+RT22+¬ACA0的模型。

test_alpha0 2022/1/28 18:37:39
下面要证明的命题是，设X不可计算，则任何二染色都有无限单色子集算不出X。

test_alpha0 2022/1/28 18:38:07
这个结论的证明的标准叙述用的是一种比较对称的方式

test_alpha0 2022/1/28 18:38:42
不过在一些其他的问题上，对称的叙述无法解决问题，只有不对称的叙述才能解决问题

test_alpha0 2022/1/28 18:39:15
所以，我会用不对称的方式叙述它的证明

test_alpha0 2022/1/28 18:39:39
首先，不妨设两种颜色的元素都有无限个，否则原问题是显然的

test_alpha0 2022/1/28 18:40:07
我们将会使用mathias forcing的这样的变种：(A,B)，其中B是无限集且不能计算出X。

test_alpha0 2022/1/28 18:41:30
我们记φ_e,0为Φ_e(G∩红)≠X，φ_e,1为Φ_e(G∩蓝)≠X

test_alpha0 2022/1/28 18:43:07
我们的目标是：先尝试满足φ_0,0，φ_1,0，φ_2,0，...。
如果某一刻，这个目的无法实现，我们就再尝试满足φ_0,1，φ_1,1，φ_2,1，...
当然，在这个过程中，需要穿插满足“A的元素个数至少为n”

test_alpha0 2022/1/28 18:44:54
假设(A,B)无法被加强为满足φ_e,0，也就是说，对任意(A,B)的加强(A',B')，存在G∈[(A',B')]，使得Φ_e(G∩红)=X

test_alpha0 2022/1/28 18:45:18
那么，(A,B)的任何加强也具有上述性质。

test_alpha0 2022/1/28 18:46:15
我们证明，对任意的f，(A,B)都可以被加强为满足φ_f,1

test_alpha0 2022/1/28 19:24:55
设A∩红=A_0，A∩蓝=A_1。
若存在B∩蓝的初始段B'和自然数n，使得Φ_f(A_1∪(B'的某个子集),n)=1-X(n)，则我们可以满足φ_f,1。

test_alpha0 2022/1/28 19:25:07
若不存在，我们注意到，由于φ_e,0无法被满足，所以Φ_e(A_0∪(B的某个红子集),n)一定没法等于1-X(n)

test_alpha0 2022/1/28 19:25:11
接下来，我们考虑两种情况：
情况1：对任意自然数n，存在B的一个长为m的初始段，使得无论怎么把它分成两块B_0,B_1，都要么有Φ_e(A_0∪(B_0的某个子集),n)=X(n)，要么有Φ_f(A_1∪(B_1的某个子集),n)=X(n)，且这个计算可以在m步之内完成。
对于这种情况，X可计算，这不可能。
(注意，这依赖于1-X(n)没有这样的拆分，因为有个拆分是沿着染色拆)

test_alpha0 2022/1/28 19:28:36
情况2：存在n，对任意m，都可以把B的长为m的初始段分成两块B_0，B_1，使得Φ_e(A_0∪(B_0的某个子集),n)和Φ_f(A_1∪(B_1的某个子集),n)都没法在m步之内算出等于X(n)。
这样的划分构成一棵二叉树。
由躲锥基引理，存在B的一个划分B_0,B_1，使得Φ_e(A_0∪(B_0的某个子集),n)和Φ_f(A_1∪(B_1的某个子集),n)都不等于X(n)，且B_0和B_1都算不出X。
现在考虑(A,B_0)，它满足了φ_e,0，这不可能——除非B_0是有限集。
由于B是无限集，B_0是有限集，所以B_1是无限集。
而(A,B_1)满足φ_f,1。

test_alpha0 2022/1/28 19:29:16
test_alpha0  
我们的目标是：先尝试满足φ_0,0，φ_1,0，φ_2,0，...。
如果某一刻，这个目的无法实现，我们就再尝试满足φ_0,1，φ_1,1，φ_2,1，...
当然，在这个过程中，需要穿插满足“A的元素个数至少为n”
这里需要补充一下，我们需要穿插满足“A至少有n个红元素和n个蓝元素”
这件事可以做到，是因为如果做不到，说明这一刻B里至多有有限个某种颜色的元素。把它们删掉后，得到的集合仍然算不出X，这样我们直接就得到了一个算不出X的单色集。

test_alpha0 2022/1/28 19:30:07
最后，A中红元素和蓝元素都是无限的，而且至少有一边算不出X。引理证毕。

test_alpha0 2022/1/28 19:31:52
最后说怎么构造模型。
首先，全体可计算集合是RCA0的模型。
设d_1≤d_2≤...是一串图灵度。若M={A|某个d_n可以算出A}，则(ω,M)也是RCA0的模型。

test_alpha0 2022/1/28 19:39:24
注意到0'是不可计算的。取X=0'。
对于(ω,M)，从M={可计算集合}开始，我们依次构造集合A_1,A_2,...。每当构造出A_n，就把A_1⊕A_2⊕...⊕A_n:=d_n可计算的集合全都加入到M中。且我们的构造要保持d_n算不出X。
设d_n可计算的全体[ω]^2二染色为c(n,1), c(n,2), ...。
在第k步，如果k不形如2^n*3^m，就取A_k=∅。如果k形如2^n*3^m，就取一个c(n,m)的通过d_(k-1)算不出X的单色子集，把它设为A_k。

test_alpha0 2022/1/28 19:42:08
这样，对于最终版本的M，每当有一个[ω]^2的二染色c，都存在某个d_n算出c，因此c是某个c(n,m)，因此A_2^n*3^m∈M是这个二染色的单色子集。
因此，(ω,M)⊨RT22。
另一方面，每个d_n都算不出X=0'，因此0'∉M。但ACA0的任何ω模型都含有0'，因此(ω,M)⊨¬ACA0

所以其实主要目的就是要在把这些东西算出来的同时避开0'……


